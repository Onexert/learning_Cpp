## Inheritance(继承) 表示 is-a
面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行效率的效果。

当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为**父类**，新建的类称为**子类**。

### 1. 父类&子类
一个类可以派生自多个类，这意味着，它可以**从多个父类继承数据和函数**。定义一个派生类，我们使用一个类派生列表来指父类。子类列表以一个或多个父类命名，形式如下：
```cpp
class derived-class: access-specifier base-class
```

访问修饰符 access-specifier 是 **public、protected** 或 **private** 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。**常用的为 public**

![[Pasted image 20220411182834.png]]
```cpp
struct _List_node_base //父类
{
  _List_node_base* _M_next;
  _List_node_base* _M_prev;
};

template<typename _Tp>
struct _List_node //子类
  : public _List_node_base
{
  _Tp _M_data;
};
```

### 2. 继承类型
当一个类派生自基类，该基类可以被继承为 **public、protected** 或 **private** 几种类型。继承类型是通过上面讲解的访问修饰符 access-specifier 来指定的。

我们几乎不使用 **protected** 或 **private** 继承，通常使用 **public** 继承。当使用不同类型的继承时，遵循以下几个规则：

-   **公有继承（public）**：当一个类派生自**公有**基类时，基类的**公有**成员也是派生类的**公有**成员，基类的**保护**成员也是派生类的**保护**成员，基类的**私有**成员不能直接被派生类访问，但是可以通过调用基类的**公有**和**保护**成员来访问。
-   **保护继承（protected）：** 当一个类派生自**保护**基类时，基类的**公有**和**保护**成员将成为派生类的**保护**成员。
-   **私有继承（private）：**当一个类派生自**私有**基类时，基类的**公有**和**保护**成员将成为派生类的**私有**成员。

### 3. Inheritance(组合)下的构造与析构
**ctor：构造函数    dtor：析构函数**
![[Pasted image 20220411184214.png]]
#### 构造由内而外
继承的构造也要由内而外。**Derived** 的构造函数首先调用 **Base class** 的 **default** 构造函数，然后才执行自己。但是对 **Base** 的 **default** 构造函数有要求是，可以根据用户需求选择调用哪一个构造函数，其操作类似 **composition**的方式。
```cpp
Derived::Derived(...): Base() {...};
```
#### 析构由外而内
其析构函数的执行刚好与其构造函数的执行顺序相反，其 **dtor**的调用是由外到内的调用
```cpp
Derived::~Derived(...) {... ~Base() };
```

> [[虚函数与多态]]

### 4. 访问控制和继承
> 子类可以访问父类中的所有非私有成员。因此父类成员如果不想被子类的成员函数访问，则应在父类中声明为 private。

访问权限：
|访问| public |	protected |	private |
|:-:|:-:|:-:|:-:|
| 同一个类| yes|yes |yes |
| 子类| yes| yes| no|
|外部的类	|yes|	no|	no|

一个子类继承了所有的父类方法，但下列情况除外：
-   父类的构造函数、析构函数和拷贝构造函数。
-   父类的重载运算符。
-   父类的友元函数。


### 5. 多继承
[[#2 继承类型]]
```cpp
class <子类名>:<继承方式1><父类名1>,<继承方式2><父类名2>,…
{
<子类类体>
};

```

#cpp #OOP #OOD #继承